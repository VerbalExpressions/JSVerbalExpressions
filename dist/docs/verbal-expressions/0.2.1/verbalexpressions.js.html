<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: verbalexpressions.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: verbalexpressions.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*!
 * VerbalExpressions JavaScript Library v0.2.1
 * https://github.com/VerbalExpressions/JSVerbalExpressions
 *
 *
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 */

/**
* Define the VerbalExpression class.
* @class
*/
(function verbalExpressionIIFE(root) {
    // Constants
    var MODULE_NAME = 'VerEx';

    /**
    * I am the constructor function.
    * @constructor
    * @alias VerEx
    * @return {VerbalExpression} A new instance of VerbalExpression
    */
    function VerbalExpression() {}

    /**
    * Track changes requiring recompile
    */
    VerbalExpression.prototype._dirty = true;

    /**
    * Cache of compiled regex
    */
    VerbalExpression.prototype._regexp = undefined;

    /**
    * Regex prefixes
    */
    VerbalExpression.prototype._prefixes = '';

    /**
    * Regex middle
    */
    VerbalExpression.prototype._source = '';

    /**
    * Regex suffixes
    */
    VerbalExpression.prototype._suffixes = '';

    /**
    * default to global multiline matching
    */
    VerbalExpression.prototype._modifiers = 'gm';

        /**
        * Sanitation function for adding anything safely to the expression
        * @param {String} value string to sanitize
        * @return {String} sanitized value
        */
    VerbalExpression.prototype.sanitize = function sanitize(value) {
        var reRegExpEscape;

        if (value.source) {
            return value.source;
        }

        if (typeof value === 'number') {
            return value;
        }

        // Regular expression meta characters, URL: https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/regexp
        reRegExpEscape = /([\].|*?+(){}^$\\:=[])/g;

        // Escape RegExp special characters only
        // $&amp; => Last match, URL: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastMatch
        return value.replace(reRegExpEscape, '\\$&amp;');
    };

    /**
    * Function to add stuff to the expression. Also compiles the new expression so it's ready to be used.
    * @param {string} value literal expression, not sanitized
    * @return {VerbalExpression} Freshly recompiled instance of VerbalExpression
    */
    VerbalExpression.prototype.add = function add(value) {
        this._source += value || '';
        this._dirty = true;

        return this;
    };

    /**
    * Control start-of-line matching
    * @param {Boolean} enable Control start-of-line matching
    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining
    */
    VerbalExpression.prototype.startOfLine = function startOfLine(enable) {
        enable = (enable !== false);
        this._prefixes = enable ? '^' : '';
        this._dirty = true;

        return this;
    };

    /**
    * Control end-of-line matching
    * @param {Boolean} enable Control end-of-line matching
    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining
    */
    VerbalExpression.prototype.endOfLine = function endOfLine(enable) {
        enable = (enable !== false);
        this._suffixes = enable ? '$' : '';
        this._dirty = true;

        return this;
    };

    /**
    * We try to keep the syntax as user-friendly as possible. So we can use the "normal" behaviour to split the "sentences" naturally.
    * @param {String} value value to find
    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining
    */
    VerbalExpression.prototype.then = function then(value) {
        value = this.sanitize(value);
        this.add('(?:' + value + ')');

        return this;
    };

    /**
    * And because we can't start with "then" function, we create an alias to be used as the first function of the chain.
    * @param {String} value value to find
    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining
    */
    VerbalExpression.prototype.find = function find(value) {
        return this.then(value);
    };

    /*
    * Maybe is used to add values with ?
    * @param {String} value value to find
    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining
    */
    VerbalExpression.prototype.maybe = function maybe(value) {
        value = this.sanitize(value);
        this.add('(?:' + value + ')?');

        return this;
    };

    /**
    * Any character any number of times
    * @param {String} value value to find
    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining
    */
    VerbalExpression.prototype.anything = function anything() {
        this.add('(?:.*)');
        return this;
    };

    /**
    * Anything but these characters
    * @param {String} value value to find
    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining
    */
    VerbalExpression.prototype.anythingBut = function anythingBut(value) {
        value = this.sanitize(value);
        this.add('(?:[^' + value + ']*)');

        return this;
    };

    /**
    * Any character at least one time
    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining
    */
    VerbalExpression.prototype.something = function something() {
        this.add('(?:.+)');
        return this;
    };

    /**
    * Any character at least one time except for these characters
    * @param {String} value value to find
    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining
    */
    VerbalExpression.prototype.somethingBut = function somethingBut(value) {
        value = this.sanitize(value);
        this.add('(?:[^' + value + ']+)');

        return this;
    };

    /**
    * Shorthand function for the String.replace function to give more logical flow if, for example, we're doing multiple replacements on one regexp.
    * @param {String} source string to search for
    * @param {String} value value to replace with
    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining
    */
    VerbalExpression.prototype.replace = function replace(source, value) {
        if (this._dirty) {
            this.toRegExp();
        }
        source = source.toString();
        return source.replace(this._regexp, value);
    };

    /// Add regular expression special ///
    /// characters                     ///

    /**
    * Line break
    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining
    */
    VerbalExpression.prototype.lineBreak = function lineBreak() {
        this.add('(?:\\r\\n|\\r|\\n)'); // Unix + Windows CRLF
        return this;
    };

    /**
    * And a shorthand for html-minded
    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining
    */
    VerbalExpression.prototype.br = function br() {
        return this.lineBreak();
    };

    /**
    * Tab (duh?)
    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining
    */
    VerbalExpression.prototype.tab = function tab() {
        this.add('\\t');
        return this;
    };

    /**
    * Any alphanumeric
    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining
    */
    VerbalExpression.prototype.word = function word() {
        this.add('\\w+');
        return this;
    };

    /**
    * Any whitespace
    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining
    */
    VerbalExpression.prototype.whitespace = function whitespace() {
        this.add('\\s');
        return this;
    };

    /**
    * Any given character
    * @param {String} value value to find
    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining
    */
    VerbalExpression.prototype.anyOf = function anyOf(value) {
        value = this.sanitize(value);
        this.add('[' + value + ']');

        return this;
    };

    /**
    * Shorthand
    * @param {String} value value to find
    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining
    */
    VerbalExpression.prototype.any = function any(value) {
        return this.anyOf(value);
    };

    /**
    * Usage: .range( from, to [, from, to ... ] )
    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining
    */
    VerbalExpression.prototype.range = function range() {
        var length = arguments.length;

        // Create a string buffer instead of concatenating on iteration
        var buffer = new Array(length / 2);
        var index = 0;
        var i = 0;
        var from;
        var to;

        buffer[index++] = '[';

        while (i &lt; length) {
            from = this.sanitize(arguments[i++]);
            to = this.sanitize(arguments[i++]);
            buffer[index++] = from + '-' + to;
        }

        buffer[index++] = ']';

        this.add(buffer.join(''));

        return this;
    };

    /// Modifiers      ///

    /**
    * Modifier abstraction
    * @param {String} modifier modifier to add
    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining
    */
    VerbalExpression.prototype.addModifier = function addModifier(modifier) {
        if (this._modifiers.indexOf(modifier) === -1) {
            this._modifiers += modifier;
            this._dirty = true;
        }

        return this;
    };

    /**
    * Remove modifier
    * @param {String} modifier modifier to remove
    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining
    */
    VerbalExpression.prototype.removeModifier = function removeModifier(modifier) {
        this._modifiers = this._modifiers.replace(modifier, '');
        this._dirty = true;

        return this;
    };

    /**
    * Case-insensitivity modifier
    * @param {Boolean} enable Control case-insensitive matching
    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining
    */
    VerbalExpression.prototype.withAnyCase = function withAnyCase(enable) {
        if (enable !== false) {
            this.addModifier('i');
        } else {
            this.removeModifier('i');
        }

        return this;
    };

    /**
    * Default behaviour is with "g" modifier, so we can turn this another way around than other modifiers
    * @param {Boolean} enable Control global matching
    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining
    */
    VerbalExpression.prototype.stopAtFirst = function stopAtFirst(enable) {
        if (enable !== false) {
            this.removeModifier('g');
        } else {
            this.addModifier('g');
        }

        return this;
    };

    /**
    * Multiline, also reversed
    * @param {Boolean} enable Control multi-line matching
    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining
    */
    VerbalExpression.prototype.searchOneLine = function searchOneLine(enable) {
        if (enable !== false) {
            this.removeModifier('m');
        } else {
            this.addModifier('m');
        }

        return this;
    };

    /**
    * Repeats the previous item exactly n times or between n and m times.
    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining
    */
    VerbalExpression.prototype.repeatPrevious = function repeatPrevious() {
        var value;
        var reIsInteger = /\d+/;
        var length = arguments.length;
        var values = new Array(length);
        var i = 0;
        var j = 0;
        for (i = 0; i &lt; length; i++) {
            if (reIsInteger.test(arguments[i])) {
                values[j++] = arguments[i];
            }
        }

        if (j > 0) {
            // Set the new length of the array, thus reducing to the elements that have content
            values.length = j;
            value = '{' + values.join(',') + '}';
        }


        this.add(value);

        return (this);
    };

    /**
    * Repeats the previous at least once
    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining
    */
    VerbalExpression.prototype.oneOrMore = function oneOrMore() {
        this.add('+');
        return (this);
    };

    /// Loops  ///

    /**
    * Matches the value zero or more times
    * @param {String} value value to find
    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining
    */
    VerbalExpression.prototype.multiple = function multiple(value) {
        // Use expression or string
        value = value.source || this.sanitize(value);
        if (arguments.length === 1) {
            this.add('(?:' + value + ')*');
        }

        if (arguments.length > 1) {
            this.add('(?:' + value + ')');
            this.add('{' + arguments[1] + '}');
        }

        return this;
    };

    /**
    * Adds alternative expressions
    * @param {String} value value to find
    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining
    */
    VerbalExpression.prototype.or = function or(value) {
        this._prefixes += '(?:';
        this._suffixes = ')' + this._suffixes;

        this.add(')|(?:');
        if (value) {
            this.then(value);
        }

        return this;
    };

    /**
    * Starts a capturing group
    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining
    */
    VerbalExpression.prototype.beginCapture = function beginCapture() {
        // Add the end of the capture group to the suffixes for now so compilation continues to work
        this._suffixes += ')';
        this.add('(');

        return this;
    };

    /**
    * Ends a capturing group
    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining
    */
    VerbalExpression.prototype.endCapture = function endCapture() {
        // Remove the last parentheses from the _suffixes and add to the regex itself
        this._suffixes = this._suffixes.substring(0, this._suffixes.length - 1);
        this.add(')');

        return this;
    };

    /**
    * Convert to RegExp object
    * @return {RegExp} Converted RegExp instance
    */
    VerbalExpression.prototype.toRegExp = function toRegExp() {
        if (this._dirty) {
            this._regexp = new RegExp(this._prefixes + this._source + this._suffixes, this._modifiers);
            this._dirty = false;
        }

        return new RegExp(this._regexp.source, this._modifiers);
    };

    /**
    * Convert regex to string
    * @return {String} string representation of verbal expression
    */
    VerbalExpression.prototype.toString = function toString() {
        return (this.toRegExp() + '');
    };

    /**
    * Test string against regex
    * @param {String} str string to test
    * @return {Boolean} true if string passes test, false otherwise
    */
    VerbalExpression.prototype.test = function test(str) {
        return this.toRegExp().test(str);
    };

    /**
    * @return {VerbalExpression} Returns a new instance of VerbalExpressions
    */
    function createVerbalExpression() {
        return new VerbalExpression();
    }

    // UMD (Universal Module Definition), URL: https://github.com/umdjs/umd
    // Supports AMD, CommonJS and the browser
    if (typeof module !== 'undefined' &amp;&amp; module.exports) {
        // Node.js Module
        module.exports = createVerbalExpression;
    } else if (typeof define === 'function' &amp;&amp; define.amd) {
        // AMD Module
        define(MODULE_NAME, [], function define() {
            return VerbalExpression;
        });
    } else {
        // Browser
        root[MODULE_NAME] = createVerbalExpression;
    }
}(this));
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="VerEx.html">VerEx</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Sun Feb 07 2016 10:35:31 GMT+0000 (GMT Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
